"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PuppeteerController = void 0;
const timeout_1 = require("@apify/timeout");
const browser_controller_1 = require("../abstract-classes/browser-controller");
const logger_1 = require("../logger");
const PROCESS_KILL_TIMEOUT_MILLIS = 5000;
class PuppeteerController extends browser_controller_1.BrowserController {
    normalizeProxyOptions(proxyUrl, pageOptions) {
        if (!proxyUrl) {
            return {};
        }
        const url = new URL(proxyUrl);
        const username = decodeURIComponent(url.username);
        const password = decodeURIComponent(url.password);
        return {
            proxyServer: url.origin,
            proxyUsername: username,
            proxyPassword: password,
            proxyBypassList: pageOptions === null || pageOptions === void 0 ? void 0 : pageOptions.proxyBypassList,
        };
    }
    async _newPage(contextOptions) {
        var _a, _b;
        if (contextOptions !== undefined) {
            if (!this.launchContext.useIncognitoPages) {
                throw new Error('A new page can be created with provided context only when using incognito pages.');
            }
            const context = await this.browser.createIncognitoBrowserContext(contextOptions);
            (0, timeout_1.tryCancel)();
            const page = await context.newPage();
            (0, timeout_1.tryCancel)();
            if (contextOptions.proxyUsername || contextOptions.proxyPassword) {
                await page.authenticate({
                    username: (_a = contextOptions.proxyUsername) !== null && _a !== void 0 ? _a : '',
                    password: (_b = contextOptions.proxyPassword) !== null && _b !== void 0 ? _b : '',
                });
                (0, timeout_1.tryCancel)();
            }
            page.once('close', async () => {
                this.activePages--;
                try {
                    await context.close();
                }
                catch (error) {
                    logger_1.log.exception(error, 'Failed to close context.');
                }
                (0, timeout_1.tryCancel)();
            });
            return page;
        }
        const page = await this.browser.newPage();
        (0, timeout_1.tryCancel)();
        page.once('close', () => {
            this.activePages--;
        });
        return page;
    }
    async _close() {
        await this.browser.close();
    }
    async _kill() {
        const browserProcess = this.browser.process();
        if (!browserProcess) {
            // TODO: LOG browser was connected using the `puppeteer.connect` method no browser to kill.
            return;
        }
        const timeout = setTimeout(() => {
            // This is here because users reported that it happened
            // that error `TypeError: Cannot read property 'kill' of null` was thrown.
            // Likely Chrome process wasn't started due to some error ...
            browserProcess === null || browserProcess === void 0 ? void 0 : browserProcess.kill('SIGKILL');
        }, PROCESS_KILL_TIMEOUT_MILLIS);
        try {
            await this.browser.close();
            clearTimeout(timeout);
        }
        catch (e) {
            // TODO: LOG Browser was already killed.
        }
    }
    _getCookies(page) {
        return page.cookies();
    }
    _setCookies(page, cookies) {
        return page.setCookie(...cookies);
    }
}
exports.PuppeteerController = PuppeteerController;
//# sourceMappingURL=puppeteer-controller.js.map