export function hashPayload(payload: any): string;
export default Request;
/**
 * Specifies required and optional fields for constructing a {@link Request }.
 */
export type RequestOptions = {
    /**
     * URL of the web page to crawl. It must be a non-empty string.
     */
    url: string;
    /**
     * A unique key identifying the request.
     * Two requests with the same `uniqueKey` are considered as pointing to the same URL.
     *
     * If `uniqueKey` is not provided, then it is automatically generated by normalizing the URL.
     * For example, the URL of `HTTP://www.EXAMPLE.com/something/` will produce the `uniqueKey`
     * of `http://www.example.com/something`.
     *
     * The `keepUrlFragment` option determines whether URL hash fragment is included in the `uniqueKey` or not.
     *
     * The `useExtendedUniqueKey` options determines whether method and payload are included in the `uniqueKey`,
     * producing a `uniqueKey` in the following format: `METHOD(payloadHash):normalizedUrl`. This is useful
     * when requests point to the same URL, but with different methods and payloads. For example: form submits.
     *
     * Pass an arbitrary non-empty text value to the `uniqueKey` property
     * to override the default behavior and specify which URLs shall be considered equal.
     */
    uniqueKey?: string | undefined;
    method?: string | undefined;
    /**
     * HTTP request payload, e.g. for POST requests.
     */
    payload?: string | Buffer | undefined;
    /**
     * HTTP headers in the following format:
     * ```
     * {
     * Accept: 'text/html',
     * 'Content-Type': 'application/json'
     * }
     * ```
     */
    headers?: {
        [x: string]: string;
    } | undefined;
    /**
     * Custom user data assigned to the request. Use this to save any request related data to the
     * request's scope, keeping them accessible on retries, failures etc.
     */
    userData?: {
        [x: string]: any;
    } | undefined;
    /**
     * If `false` then the hash part of a URL is removed when computing the `uniqueKey` property.
     * For example, this causes the `http://www.example.com#foo` and `http://www.example.com#bar` URLs
     * to have the same `uniqueKey` of `http://www.example.com` and thus the URLs are considered equal.
     * Note that this option only has an effect if `uniqueKey` is not set.
     */
    keepUrlFragment?: boolean | undefined;
    /**
     * If `true` then the `uniqueKey` is computed not only from the URL, but also from the method and payload
     * properties. This is useful when making requests to the same URL that are differentiated by method
     * or payload, such as form submit navigations in browsers.
     */
    useExtendedUniqueKey?: boolean | undefined;
};
/**
 * Represents a URL to be crawled, optionally including HTTP method, headers, payload and other metadata.
 * The `Request` object also stores information about errors that occurred during processing of the request.
 *
 * Each `Request` instance has the `uniqueKey` property, which can be either specified
 * manually in the constructor or generated automatically from the URL. Two requests with the same `uniqueKey`
 * are considered as pointing to the same web resource. This behavior applies to all Apify SDK classes,
 * such as {@link RequestList}, {@link RequestQueue}, {@link PuppeteerCrawler} or {@link PlaywrightCrawler}.
 *
 * Example use:
 *
 * ```javascript
 * const request = new Apify.Request({
 *     url: 'http://www.example.com',
 *     headers: { Accept: 'application/json' },
 * });
 *
 * ...
 *
 * request.userData.foo = 'bar';
 * request.pushErrorMessage(new Error('Request failed!'));
 *
 * ...
 *
 * const foo = request.userData.foo;
 * ```
 *
 * @property {string} id
 *   Request ID
 * @property {string} url
 *   URL of the web page to crawl.
 * @property {string} loadedUrl
 *   An actually loaded URL after redirects, if present. HTTP redirects are guaranteed
 *   to be included.
 *
 *   When using {@link PuppeteerCrawler} or {@link PlaywrightCrawler}, meta tag and JavaScript redirects may,
 *   or may not be included, depending on their nature. This generally means that redirects,
 *   which happen immediately will most likely be included, but delayed redirects will not.
 * @property {string} uniqueKey
 *   A unique key identifying the request.
 *   Two requests with the same `uniqueKey` are considered as pointing to the same URL.
 * @property {string} method
 *   HTTP method, e.g. `GET` or `POST`.
 * @property {(string|Buffer)} payload
 *   HTTP request payload, e.g. for POST requests.
 * @property {boolean} noRetry
 *   The `true` value indicates that the request will not be automatically retried on error.
 * @property {number} retryCount
 *   Indicates the number of times the crawling of the request has been retried on error.
 * @property {string[]} errorMessages
 *   An array of error messages from request processing.
 * @property {Object<string, string>} headers
 *   Object with HTTP headers. Key is header name, value is the value.
 * @property {Object<string, *>} userData
 *   Custom user data assigned to the request.
 * @property {Date} handledAt
 *   Indicates the time when the request has been processed.
 *   Is `null` if the request has not been crawled yet.
 */
declare class Request {
    /**
     * @param {RequestOptions} options
     * `Request` parameters including the URL, HTTP method and headers, and others.
     */
    constructor(options: RequestOptions);
    id: any;
    url: string;
    loadedUrl: any;
    uniqueKey: any;
    method: string;
    payload: string | Buffer | undefined;
    noRetry: any;
    retryCount: any;
    errorMessages: any[];
    /** @type {Object<string, string>} */
    headers: {
        [x: string]: string;
    };
    /** @type {Object<string, any>} */
    userData: {
        [x: string]: any;
    };
    handledAt: any;
    /**
     * Stores information about an error that occurred during processing of this request.
     *
     * You should always use Error instances when throwing errors in JavaScript.
     *
     * Nevertheless, to improve the debugging experience when using third party libraries
     * that may not always throw an Error instance, the function performs a type
     * inspection of the passed argument and attempts to extract as much information
     * as possible, since just throwing a bad type error makes any debugging rather difficult.
     *
     * @param {(Error|string)} errorOrMessage Error object or error message to be stored in the request.
     * @param {object} [options]
     * @param {boolean} [options.omitStack=false] Only push the error message without stack trace when true.
     */
    pushErrorMessage(errorOrMessage: (Error | string), options?: {
        omitStack?: boolean | undefined;
    } | undefined): void;
    /**
     * @ignore
     * @protected
     * @internal
     */
    protected _computeUniqueKey({ url, method, payload, keepUrlFragment, useExtendedUniqueKey }: {
        url: any;
        method: any;
        payload: any;
        keepUrlFragment: any;
        useExtendedUniqueKey: any;
    }): any;
}
//# sourceMappingURL=request.d.ts.map