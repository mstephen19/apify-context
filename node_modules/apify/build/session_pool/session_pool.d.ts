/**
 * Factory user-function which creates customized {@link Session} instances.
 * @callback CreateSession
 * @param {SessionPool} sessionPool Pool requesting the new session.
 * @returns {Promise<Session>}
 */
/**
 * @typedef SessionPoolOptions
 * @property {number} [maxPoolSize=1000] - Maximum size of the pool.
 * Indicates how many sessions are rotated.
 * @property {SessionOptions} [sessionOptions] The configuration options for {@link Session} instances.
 * @property {string} [persistStateKeyValueStoreId] - Name or Id of `KeyValueStore` where is the `SessionPool` state stored.
 * @property {string} [persistStateKey="SESSION_POOL_STATE"] - Session pool persists it's state under this key in Key value store.
 * @property {CreateSession} [createSessionFunction] - Custom function that should return `Session` instance.
 * Any error thrown from this function will terminate the process.
 * Function receives `SessionPool` instance as a parameter
 * @property {boolean} [forceCloud=false] If set to `true` then the function uses cloud storage usage even if the `APIFY_LOCAL_STORAGE_DIR`
 * environment variable is set. This way it is possible to combine local and cloud storage.
 *
 * **Note:** If you use `forceCloud`, it is recommended to also set the `persistStateKeyValueStoreId` option, as otherwise the
 * `KeyValueStore` will be unnamed!
 */
/**
 * Handles the rotation, creation and persistence of user-like sessions.
 * Creates a pool of {@link Session} instances, that are randomly rotated.
 * When some session is marked as blocked, it is removed and new one is created instead (the pool never returns an unusable session).
 * Learn more in the [`Session management guide`](../guides/session-management).
 *
 * You can create one by calling the {@link Apify.openSessionPool} function.
 *
 * Session pool is already integrated into crawlers, and it can significantly improve your scraper
 * performance with just 2 lines of code.
 *
 * **Example usage:**
 *
 * ```javascript
 * const crawler = new Apify.CheerioCrawler({
 *     useSessionPool: true,
 *     persistCookiesPerSession: true,
 *     // ...
 * })
 * ```
 *
 * You can configure the pool with many options. See the {@link SessionPoolOptions}.
 * Session pool is by default persisted in default {@link KeyValueStore}.
 * If you want to have one pool for all runs you have to specify
 * {@link SessionPoolOptions.persistStateKeyValueStoreId}.
 *
 * **Advanced usage:**
 *
 * ```javascript
 * const sessionPool = await Apify.openSessionPool({
 *     maxPoolSize: 25,
 *     sessionOptions:{
 *          maxAgeSecs: 10,
 *          maxUsageCount: 150, // for example when you know that the site blocks after 150 requests.
 *     },
 *     persistStateKeyValueStoreId: 'my-key-value-store-for-sessions',
 *     persistStateKey: 'my-session-pool',
 * });
 *
 * // Get random session from the pool
 * const session1 = await sessionPool.getSession();
 * const session2 = await sessionPool.getSession();
 * const session3 = await sessionPool.getSession();
 *
 * // Now you can mark the session either failed or successful
 *
 * // Marks session as bad after unsuccessful usage -> it increases error count (soft retire)
 * session1.markBad()
 *
 * // Marks as successful.
 * session2.markGood()
 *
 * // Retires session -> session is removed from the pool
 * session3.retire()
 *
 * ```
 * @hideconstructor
 */
export class SessionPool extends EventEmitter {
    /**
     * Session pool configuration.
     * @param {SessionPoolOptions} [options] All `SessionPool` configuration options.
     * @param {Configuration} [config]
     */
    constructor(options?: SessionPoolOptions | undefined, config?: Configuration | undefined);
    config: Configuration;
    log: any;
    maxPoolSize: number;
    createSessionFunction: (CreateSession & Function) | ((sessionPool: SessionPool, options?: {
        sessionOptions?: SessionOptions | undefined;
    } | undefined) => Session);
    sessionOptions: {
        log: any;
    };
    persistStateKeyValueStoreId: string | undefined;
    persistStateKey: string;
    keyValueStore: import("../storages/key_value_store").KeyValueStore | null;
    /** @type {Session[]} */
    sessions: Session[];
    sessionMap: Map<any, any>;
    /** @type {boolean} */
    forceCloud: boolean;
    /**
     * Gets count of usable sessions in the pool.
     * @return {number}
     */
    get usableSessionsCount(): number;
    /**
     * Gets count of retired sessions in the pool.
     * @return {number}
     */
    get retiredSessionsCount(): number;
    /**
     * Starts periodic state persistence and potentially loads SessionPool state from {@link KeyValueStore}.
     * It is called automatically by the {@link Apify.openSessionPool} function.
     *
     * @return {Promise<void>}
     */
    initialize(): Promise<void>;
    _listener: (() => Promise<void>) | undefined;
    /**
     * Adds a new session to the session pool. The pool automatically creates sessions up to the maximum size of the pool,
     * but this allows you to add more sessions once the max pool size is reached.
     * This also allows you to add session with overridden session options (e.g. with specific session id).
     * @param {Session|SessionOptions} [options] - The configuration options for the session being added to the session pool.
     */
    addSession(options?: Session | SessionOptions | undefined): Promise<void>;
    /**
     * Gets session.
     * If there is space for new session, it creates and returns new session.
     * If the session pool is full, it picks a session from the pool,
     * If the picked session is usable it is returned, otherwise it creates and returns a new one.
     *
     * @param {String} [sessionId] - If provided, it returns the usable session with this id, `undefined` otherwise.
     * @return {Promise<Session>}
     */
    getSession(sessionId?: string | undefined): Promise<Session>;
    /**
     * Returns an object representing the internal state of the `SessionPool` instance.
     * Note that the object's fields can change in future releases.
     */
    getState(): {
        usableSessionsCount: number;
        retiredSessionsCount: number;
        sessions: import("./session").SessionState[];
    };
    /**
     * Persists the current state of the `SessionPool` into the default {@link KeyValueStore}.
     * The state is persisted automatically in regular intervals.
     *
     * @return {Promise<void>}
     */
    persistState(): Promise<void>;
    /**
     * Removes listener from `persistState` event.
     * This function should be called after you are done with using the `SessionPool` instance.
     */
    teardown(): Promise<void>;
    /**
     * SessionPool should not work before initialization.
     * @ignore
     * @protected
     * @internal
     */
    protected _throwIfNotInitialized(): void;
    /**
     * Removes retired `Session` instances from `SessionPool`.
     * @ignore
     * @protected
     * @internal
     */
    protected _removeRetiredSessions(): void;
    /**
     * Adds `Session` instance to `SessionPool`.
     * @param {Session} newSession `Session` instance to be added.
     * @ignore
     * @protected
     * @internal
     */
    protected _addSession(newSession: Session): void;
    /**
     * Gets random index.
     * @return {number}
     * @ignore
     * @protected
     * @internal
     */
    protected _getRandomIndex(): number;
    /**
     * Creates new session without any extra behavior.
     * @param {SessionPool} sessionPool
     * @param {Object} [options]
     * @param {SessionOptions} [options.sessionOptions] - The configuration options for the session being created
     * @return {Session} - New session.
     * @ignore
     * @protected
     * @internal
     */
    protected _defaultCreateSessionFunction(sessionPool: SessionPool, options?: {
        sessionOptions?: SessionOptions | undefined;
    } | undefined): Session;
    /**
     * Creates new session and adds it to the pool.
     * @return {Promise<Session>} - Newly created `Session` instance.
     * @ignore
     * @protected
     * @internal
     */
    protected _createSession(): Promise<Session>;
    /**
     * Decides whether there is enough space for creating new session.
     * @return {boolean}
     * @ignore
     * @protected
     * @internal
     */
    protected _hasSpaceForSession(): boolean;
    /**
     * Picks random session from the `SessionPool`.
     * @return {Session} - Picked `Session`
     * @ignore
     * @protected
     * @internal
     */
    protected _pickSession(): Session;
    /**
     * Potentially loads `SessionPool`.
     * If the state was persisted it loads the `SessionPool` from the persisted state.
     * @return {Promise<void>}
     * @ignore
     * @protected
     * @internal
     */
    protected _maybeLoadSessionPool(): Promise<void>;
}
export function openSessionPool(sessionPoolOptions: SessionPoolOptions): Promise<SessionPool>;
/**
 * Factory user-function which creates customized {@link Session } instances.
 */
export type CreateSession = (sessionPool: SessionPool) => Promise<Session>;
export type SessionPoolOptions = {
    /**
     * - Maximum size of the pool.
     * Indicates how many sessions are rotated.
     */
    maxPoolSize?: number | undefined;
    /**
     * The configuration options for {@link Session } instances.
     */
    sessionOptions?: SessionOptions | undefined;
    /**
     * - Name or Id of `KeyValueStore` where is the `SessionPool` state stored.
     */
    persistStateKeyValueStoreId?: string | undefined;
    /**
     * - Session pool persists it's state under this key in Key value store.
     */
    persistStateKey?: string | undefined;
    /**
     * - Custom function that should return `Session` instance.
     * Any error thrown from this function will terminate the process.
     * Function receives `SessionPool` instance as a parameter
     */
    createSessionFunction?: CreateSession | undefined;
    /**
     * If set to `true` then the function uses cloud storage usage even if the `APIFY_LOCAL_STORAGE_DIR`
     * environment variable is set. This way it is possible to combine local and cloud storage.
     *
     * **Note:** If you use `forceCloud`, it is recommended to also set the `persistStateKeyValueStoreId` option, as otherwise the
     * `KeyValueStore` will be unnamed!
     */
    forceCloud?: boolean | undefined;
};
import { EventEmitter } from "events";
import { Configuration } from "../configuration";
import { SessionOptions } from "./session";
import { Session } from "./session";
//# sourceMappingURL=session_pool.d.ts.map