export function gotoExtended(page: Page, request: Request, gotoOptions?: any): Promise<(any | null)>;
export function infiniteScroll(page: Page, options?: {
    timeoutSecs?: number | undefined;
    waitForSecs?: number | undefined;
    scrollDownAndUp?: boolean | undefined;
    buttonSelector?: string | undefined;
    stopScrollCallback?: Function | undefined;
} | undefined): Promise<void>;
export namespace puppeteerUtils {
    export { injectFile };
    export { injectJQuery };
    export { injectUnderscore };
    export { enqueueLinksByClickingElements };
    export { blockRequests };
    export { blockResources };
    export { cacheResponses };
    export { compileScript };
    export { gotoExtended };
    export { addInterceptRequestHandler };
    export { removeInterceptRequestHandler };
    export { infiniteScroll };
    export { saveSnapshot };
}
export type CompiledScriptParams = {
    page: Page;
    request: Request;
};
export type CompiledScriptFunction = (params: CompiledScriptParams) => Promise<any>;
// @ts-ignore optional peer dependency
import { Page } from "puppeteer";
/**
 * Injects a JavaScript file into a Puppeteer page.
 * Unlike Puppeteer's `addScriptTag` function, this function works on pages
 * with arbitrary Cross-Origin Resource Sharing (CORS) policies.
 *
 * File contents are cached for up to 10 files to limit file system access.
 *
 * @param {Page} page
 *   Puppeteer [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page) object.
 * @param {string} filePath File path
 * @param {object} [options]
 * @param {boolean} [options.surviveNavigations]
 *   Enables the injected script to survive page navigations and reloads without need to be re-injected manually.
 *   This does not mean, however, that internal state will be preserved. Just that it will be automatically
 *   re-injected on each navigation before any other scripts get the chance to execute.
 * @return {Promise<*>}
 * @memberOf puppeteer
 */
declare function injectFile(page: Page, filePath: string, options?: {
    surviveNavigations?: boolean | undefined;
} | undefined): Promise<any>;
/**
 * Injects the [jQuery](https://jquery.com/) library into a Puppeteer page.
 * jQuery is often useful for various web scraping and crawling tasks.
 * For example, it can help extract text from HTML elements using CSS selectors.
 *
 * Beware that the injected jQuery object will be set to the `window.$` variable and thus it might cause conflicts with
 * other libraries included by the page that use the same variable name (e.g. another version of jQuery).
 * This can affect functionality of page's scripts.
 *
 * The injected jQuery will survive page navigations and reloads.
 *
 * **Example usage:**
 * ```javascript
 * await Apify.utils.puppeteer.injectJQuery(page);
 * const title = await page.evaluate(() => {
 *   return $('head title').text();
 * });
 * ```
 *
 * Note that `injectJQuery()` does not affect the Puppeteer's
 * [`page.$()`](https://pptr.dev/#?product=Puppeteer&show=api-pageselector)
 * function in any way.
 *
 * @param {Page} page
 *   Puppeteer [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page) object.
 * @return {Promise<*>}
 * @memberOf puppeteer
 */
declare function injectJQuery(page: Page): Promise<any>;
/**
 * Injects the [Underscore](https://underscorejs.org/) library into a Puppeteer page.
 *
 * Beware that the injected Underscore object will be set to the `window._` variable and thus it might cause conflicts with
 * libraries included by the page that use the same variable name.
 * This can affect functionality of page's scripts.
 *
 * The injected Underscore will survive page navigations and reloads.
 *
 * **Example usage:**
 * ```javascript
 * await Apify.utils.puppeteer.injectUnderscore(page);
 * const escapedHtml = await page.evaluate(() => {
 *   return _.escape('<h1>Hello</h1>');
 * });
 * ```
 *
 * @param {Page} page Puppeteer [Page](https://github.com/puppeteer/puppeteer/blob/master/docs/api.md#class-page) object.
 * @return {Promise<*>}
 * @memberOf puppeteer
 */
declare function injectUnderscore(page: Page): Promise<any>;
import { enqueueLinksByClickingElements } from "./enqueue_links/click_elements";
/**
 * Forces the Puppeteer browser tab to block loading URLs that match a provided pattern.
 * This is useful to speed up crawling of websites, since it reduces the amount
 * of data that needs to be downloaded from the web, but it may break some websites
 * or unexpectedly prevent loading of resources.
 *
 * By default, the function will block all URLs including the following patterns:
 *
 * ```json
 * [".css", ".jpg", ".jpeg", ".png", ".svg", ".gif", ".woff", ".pdf", ".zip"]
 * ```
 *
 * If you want to extend this list further, use the `extraUrlPatterns` option,
 * which will keep blocking the default patterns, as well as add your custom ones.
 * If you would like to block only specific patterns, use the `urlPatterns` option,
 * which will override the defaults and block only URLs with your custom patterns.
 *
 * This function does not use Puppeteer's request interception and therefore does not interfere
 * with browser cache. It's also faster than blocking requests using interception,
 * because the blocking happens directly in the browser without the round-trip to Node.js,
 * but it does not provide the extra benefits of request interception.
 *
 * The function will never block main document loads and their respective redirects.
 *
 * **Example usage**
 * ```javascript
 * const Apify = require('apify');
 *
 * const browser = await Apify.launchPuppeteer();
 * const page = await browser.newPage();
 *
 * // Block all requests to URLs that include `adsbygoogle.js` and also all defaults.
 * await Apify.utils.puppeteer.blockRequests(page, {
 *     extraUrlPatterns: ['adsbygoogle.js'],
 * });
 *
 * await page.goto('https://cnn.com');
 * ```
 *
 * @param {Page} page
 *   Puppeteer [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page) object.
 * @param {object} [options]
 * @param {string[]} [options.urlPatterns]
 *   The patterns of URLs to block from being loaded by the browser.
 *   Only `*` can be used as a wildcard. It is also automatically added to the beginning
 *   and end of the pattern. This limitation is enforced by the DevTools protocol.
 *   `.png` is the same as `*.png*`.
 * @param {string[]} [options.extraUrlPatterns]
 *   If you just want to append to the default blocked patterns, use this property.
 * @return {Promise<void>}
 * @memberOf puppeteer
 */
declare function blockRequests(page: Page, options?: {
    urlPatterns?: string[] | undefined;
    extraUrlPatterns?: string[] | undefined;
} | undefined): Promise<void>;
/**
 * `blockResources()` has a high impact on performance in recent versions of Puppeteer.
 * 'Until this resolves, please use `Apify.utils.puppeteer.blockRequests()`.
 * @deprecated
 */
declare function blockResources(page: any, resourceTypes?: string[]): Promise<void>;
/**
 * *NOTE:* In recent versions of Puppeteer using this function entirely disables browser cache which resolves in sub-optimal
 * performance. Until this resolves, we suggest just relying on the in-browser cache unless absolutely necessary.
 *
 * Enables caching of intercepted responses into a provided object. Automatically enables request interception in Puppeteer.
 * *IMPORTANT*: Caching responses stores them to memory, so too loose rules could cause memory leaks for longer running crawlers.
 *   This issue should be resolved or atleast mitigated in future iterations of this feature.
 * @param {Page} page
 *   Puppeteer [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page) object.
 * @param {Object<string, *>} cache
 *   Object in which responses are stored
 * @param {Array<(string|RegExp)>} responseUrlRules
 *   List of rules that are used to check if the response should be cached.
 *   String rules are compared as page.url().includes(rule) while RegExp rules are evaluated as rule.test(page.url()).
 * @return {Promise<void>}
 * @memberOf puppeteer
 * @deprecated
 */
declare function cacheResponses(page: Page, cache: {
    [x: string]: any;
}, responseUrlRules: Array<(string | RegExp)>): Promise<void>;
/**
 * Compiles a Puppeteer script into an async function that may be executed at any time
 * by providing it with the following object:
 * ```
 * {
 *    page: Page,
 *    request: Request,
 * }
 * ```
 * Where `page` is a Puppeteer [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page)
 * and `request` is a {@link Request}.
 *
 * The function is compiled by using the `scriptString` parameter as the function's body,
 * so any limitations to function bodies apply. Return value of the compiled function
 * is the return value of the function body = the `scriptString` parameter.
 *
 * As a security measure, no globals such as `process` or `require` are accessible
 * from within the function body. Note that the function does not provide a safe
 * sandbox and even though globals are not easily accessible, malicious code may
 * still execute in the main process via prototype manipulation. Therefore you
 * should only use this function to execute sanitized or safe code.
 *
 * Custom context may also be provided using the `context` parameter. To improve security,
 * make sure to only pass the really necessary objects to the context. Preferably making
 * secured copies beforehand.
 *
 * @param {string} scriptString
 * @param {Object<string, *>} context
 * @return {CompiledScriptFunction}
 * @memberOf puppeteer
 */
declare function compileScript(scriptString: string, context?: {
    [x: string]: any;
}): CompiledScriptFunction;
import { addInterceptRequestHandler } from "./puppeteer_request_interception";
import { removeInterceptRequestHandler } from "./puppeteer_request_interception";
/**
 * Saves a full screenshot and HTML of the current page into a Key-Value store.
 * @param {Page} page
 *   Puppeteer [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page) object.
 * @param {object} [options]
 * @param {string} [options.key=SNAPSHOT]
 *   Key under which the screenshot and HTML will be saved. `.jpg` will be appended for screenshot and `.html` for HTML.
 * @param {number} [options.screenshotQuality=50]
 *   The quality of the image, between 0-100. Higher quality images have bigger size and require more storage.
 * @param {boolean} [options.saveScreenshot=true]
 *   If true, it will save a full screenshot of the current page as a record with `key` appended by `.jpg`.
 * @param {boolean} [options.saveHtml=true]
 *   If true, it will save a full HTML of the current page as a record with `key` appended by `.html`.
 * @param {string|null} [options.keyValueStoreName=null]
 *   Name or id of the Key-Value store where snapshot is saved. By default it is saved to default Key-Value store.
 * @returns {Promise<void>}
 * @memberOf puppeteer
 * @name saveSnapshot
 */
declare function saveSnapshot(page: Page, options?: {
    key?: string | undefined;
    screenshotQuality?: number | undefined;
    saveScreenshot?: boolean | undefined;
    saveHtml?: boolean | undefined;
    keyValueStoreName?: string | null | undefined;
} | undefined): Promise<void>;
export {};
//# sourceMappingURL=puppeteer_utils.d.ts.map