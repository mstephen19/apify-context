/**
 * @typedef BrowserCrawlingContext
 * @property {BrowserController} browserController
 */
/**
 * @callback Hook
 * @param {BrowserCrawlingContext & CrawlingContext} crawlingContext
 * @param {Object<string,*>} gotoOptions
 * @returns {Promise<void>}
 */
/**
 * @callback BrowserHandlePageFunction
 * @param {BrowserCrawlingContext & CrawlingContext} context
 * @returns {Promise<void>}
 */
/**
 * @callback GotoFunction
 * @param {BrowserCrawlingContext & CrawlingContext} context
 * @param {Object<string,*>} gotoOptions
 * @returns {Promise<*>}
 */
/**
 * @typedef BrowserCrawlerOptions
 * @property {BrowserHandlePageFunction} handlePageFunction
 *   Function that is called to process each request.
 *   It is passed an object with the following fields:
 *
 * ```
 * {
 *   request: Request,
 *   response: Response,
 *   page: Page,
 *   session: Session,
 *   browserController: BrowserController,
 *   proxyInfo: ProxyInfo,
 *   crawler: BrowserCrawler,
 * }
 * ```
 *
 *   `request` is an instance of the {@link Request} object with details about the URL to open, HTTP method etc.
 *   `page` is an instance of the `Puppeteer`
 *   [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page) or `Playwright`
 *   [`Page`](https://playwright.dev/docs/api/class-page)
 *   `browserPool` is an instance of the
 *   [`BrowserPool`](https://github.com/apify/browser-pool#BrowserPool),
 *   `browserController` is an instance of the
 *   [`BrowserController`](https://github.com/apify/browser-pool#browsercontroller),
 *   `response` is an instance of the `Puppeteer`
 *   [`Response`](https://pptr.dev/#?product=Puppeteer&show=api-class-response) or `Playwright`
 *   [`Response`](https://playwright.dev/docs/api/class-response),
 *   which is the main resource response as returned by `page.goto(request.url)`.
 *   The function must return a promise, which is then awaited by the crawler.
 *
 *   If the function throws an exception, the crawler will try to re-crawl the
 *   request later, up to `option.maxRequestRetries` times.
 *   If all the retries fail, the crawler calls the function
 *   provided to the `handleFailedRequestFunction` parameter.
 *   To make this work, you should **always**
 *   let your function throw exceptions rather than catch them.
 *   The exceptions are logged to the request using the
 *   {@link Request#pushErrorMessage} function.
 * @property {number} [handlePageTimeoutSecs=60]
 *   Timeout in which the function passed as `handlePageFunction` needs to finish, in seconds.
 * @property {GotoFunction} [gotoFunction]
 *   Navigation function for corresponding library. `page.goto(url)` is supported by both `playwright` and `puppeteer`.
 * @property {HandleFailedRequest} [handleFailedRequestFunction]
 *   A function to handle requests that failed more than `option.maxRequestRetries` times.
 *
 *   The function receives the following object as an argument:
 * ```
 * {
 *   request: Request,
 *   response: Response,
 *   page: Page,
 *   browserPool: BrowserPool,
 *   autoscaledPool: AutoscaledPool,
 *   session: Session,
 *   browserController: BrowserController,
 *   proxyInfo: ProxyInfo,
 * }
 * ```
 *   Where the {@link Request} instance corresponds to the failed request, and the `Error` instance
 *   represents the last error thrown during processing of the request.
 * @property {BrowserPoolOptions} [browserPoolOptions]
 *   Custom options passed to the underlying [`BrowserPool`](https://github.com/apify/browser-pool#BrowserPool) constructor.
 *   You can tweak those to fine-tune browser management.
 * @property {boolean} [persistCookiesPerSession=true]
 *   Automatically saves cookies to Session. Works only if Session Pool is used.
 * @property {ProxyConfiguration} [proxyConfiguration]
 *   If set, `PuppeteerCrawler` will be configured for all connections to use
 *   [Apify Proxy](https://console.apify.com/proxy) or your own Proxy URLs provided and rotated according to the configuration.
 *   For more information, see the [documentation](https://docs.apify.com/proxy).
 * @property {Array<Hook>} [preNavigationHooks]
 *   Async functions that are sequentially evaluated before the navigation. Good for setting additional cookies
 *   or browser properties before navigation. The function accepts two parameters, `crawlingContext` and `gotoOptions`,
 *   which are passed to the `page.goto()` function the crawler calls to navigate.
 *   Example:
 * ```
 * preNavigationHooks: [
 *     async (crawlingContext, gotoOptions) => {
 *         const { page } = crawlingContext;
 *         await page.evaluate((attr) => { window.foo = attr; }, 'bar');
 *     },
 * ]
 * ```
 * @property {Array<Hook>} [postNavigationHooks]
 *   Async functions that are sequentially evaluated after the navigation. Good for checking if the navigation was successful.
 *   The function accepts `crawlingContext` as the only parameter.
 *   Example:
 * ```
 * postNavigationHooks: [
 *     async (crawlingContext) => {
 *         const { page } = crawlingContext;
 *         if (hasCaptcha(page)) {
 *             await solveCaptcha (page);
 *         }
 *     },
 * ]
 * ```
 * @property {RequestList} [requestList]
 *   Static list of URLs to be processed.
 *   Either `requestList` or `requestQueue` option must be provided (or both).
 * @property {RequestQueue} [requestQueue]
 *   Dynamic queue of URLs to be processed. This is useful for recursive crawling of websites.
 *   Either `requestList` or `requestQueue` option must be provided (or both).
 * @property {number} [handleRequestTimeoutSecs=60]
 *   Timeout in which the function passed as `handleRequestFunction` needs to finish, in seconds.
 * @property {HandleFailedRequest} [handleFailedRequestFunction]
 *   A function to handle requests that failed more than `option.maxRequestRetries` times.
 *
 *   The function receives the following object as an argument:
 * ```
 * {
 *   request: Request,
 *   error: Error,
 *   session: Session,
 *   crawler: BrowserCrawler,
 * }
 * ```
 *   where the {@link Request} instance corresponds to the failed request, and the `Error` instance
 *   represents the last error thrown during processing of the request.
 *
 *   See
 *   [source code](https://github.com/apify/apify-js/blob/master/src/crawlers/basic_crawler.js#L11)
 *   for the default implementation of this function.
 * @property {number} [maxRequestRetries=3]
 *   Indicates how many times the request is retried if {@link BasicCrawlerOptions.handleRequestFunction} fails.
 * @property {number} [maxRequestsPerCrawl]
 *   Maximum number of pages that the crawler will open. The crawl will stop when this limit is reached.
 *   Always set this value in order to prevent infinite loops in misconfigured crawlers.
 *   Note that in cases of parallel crawling, the actual number of pages visited might be slightly higher than this value.
 * @property {AutoscaledPoolOptions} [autoscaledPoolOptions]
 *   Custom options passed to the underlying {@link AutoscaledPool} constructor.
 *   Note that the `runTaskFunction` and `isTaskReadyFunction` options
 *   are provided by `BasicCrawler` and cannot be overridden.
 *   However, you can provide a custom implementation of `isFinishedFunction`.
 * @property {number} [minConcurrency=1]
 *   Sets the minimum concurrency (parallelism) for the crawl. Shortcut to the corresponding {@link AutoscaledPool} option.
 *
 *   *WARNING:* If you set this value too high with respect to the available system memory and CPU, your crawler will run extremely slow or crash.
 *   If you're not sure, just keep the default value and the concurrency will scale up automatically.
 * @property {number} [maxConcurrency=1000]
 *   Sets the maximum concurrency (parallelism) for the crawl. Shortcut to the corresponding {@link AutoscaledPool} option.
 * @property {boolean} [useSessionPool=true]
 *   Browser crawler will initialize the  {@link SessionPool} with the corresponding `sessionPoolOptions`.
 *   The session instance will be than available in the `handleRequestFunction`.
 * @property {SessionPoolOptions} [sessionPoolOptions] The configuration options for {@link SessionPool} to use.
 * @ignore
 */
/**
 * Provides a simple framework for parallel crawling of web pages
 * using headless browsers with [Puppeteer](https://github.com/puppeteer/puppeteer)
 * and [Playwright](https://github.com/microsoft/playwright).
 * The URLs to crawl are fed either from a static list of URLs
 * or from a dynamic queue of URLs enabling recursive crawling of websites.
 *
 * Since `BrowserCrawler` uses headless or even headfull browsers to download web pages and extract data,
 * it is useful for crawling of websites that require to execute JavaScript.
 * If the target website doesn't need JavaScript, consider using {@link CheerioCrawler},
 * which downloads the pages using raw HTTP requests and is about 10x faster. @TODO: more?
 *
 * The source URLs are represented using {@link Request} objects that are fed from
 * {@link RequestList} or {@link RequestQueue} instances provided by the {@link BrowserCrawlerOptions.requestList}
 * or {@link BrowserCrawlerOptions.requestQueue} constructor options, respectively.
 *
 * If both {@link BrowserCrawlerOptions.requestList} and {@link BrowserCrawlerOptions.requestQueue} are used,
 * the instance first processes URLs from the {@link RequestList} and automatically enqueues all of them
 * to {@link RequestQueue} before it starts their processing. This ensures that a single URL is not crawled multiple times.
 *
 * The crawler finishes when there are no more {@link Request} objects to crawl.
 *
 * `BrowserCrawler` opens a new browser page (i.e. tab or window) for each {@link Request} object to crawl
 * and then calls the function provided by user as the {@link BrowserCrawlerOptions.handlePageFunction} option.
 *
 * New pages are only opened when there is enough free CPU and memory available,
 * using the functionality provided by the {@link AutoscaledPool} class.
 * All {@link AutoscaledPool} configuration options can be passed to the {@link BrowserCrawlerOptions.autoscaledPoolOptions}
 * parameter of the `BrowserCrawler` constructor. For user convenience, the `minConcurrency` and `maxConcurrency`
 * {@link AutoscaledPoolOptions} are available directly in the `BrowserCrawler` constructor.
 *
 * Note that the pool of browser instances is internally managed by the {@link BrowserPool} class.
 *
 * await crawler.run();
 * ```
 * @property {Statistics} stats
 *  Contains statistics about the current run.
 * @property {RequestList} [requestList]
 *  A reference to the underlying {@link RequestList} class that manages the crawler's {@link Request}s.
 *  Only available if used by the crawler.
 * @property {RequestQueue} [requestQueue]
 *  A reference to the underlying {@link RequestQueue} class that manages the crawler's {@link Request}s.
 *  Only available if used by the crawler.
 * @property {SessionPool} [sessionPool]
 *  A reference to the underlying {@link SessionPool} class that manages the crawler's {@link Session}s.
 *  Only available if used by the crawler.
 * @property {ProxyConfiguration} [proxyConfiguration]
 *  A reference to the underlying {@link ProxyConfiguration} class that manages the crawler's proxies.
 *  Only available if used by the crawler.
 * @property {BrowserPool} browserPool
 *  A reference to the underlying `BrowserPool` class that manages the crawler's browsers.
 *  For more information about it, see the [`browser-pool` module](https://github.com/apify/browser-pool).
 * @property {AutoscaledPool} autoscaledPool
 *  A reference to the underlying {@link AutoscaledPool} class that manages the concurrency of the crawler.
 *  Note that this property is only initialized after calling the {@link CheerioCrawler#run} function.
 *  You can use it to change the concurrency settings on the fly,
 *  to pause the crawler by calling {@link AutoscaledPool#pause}
 *  or to abort it by calling {@link AutoscaledPool#abort}.
 * @ignore
 */
export default class BrowserCrawler extends BasicCrawler {
    /**
     * @param {BrowserCrawlerOptions} options
     * All `BrowserCrawler` parameters are passed via an options object.
     */
    constructor(options: BrowserCrawlerOptions);
    handlePageFunction: BrowserHandlePageFunction;
    handlePageTimeoutSecs: number;
    handlePageTimeoutMillis: number;
    navigationTimeoutMillis: number;
    gotoFunction: GotoFunction | undefined;
    defaultGotoOptions: {
        timeout: number;
    };
    proxyConfiguration: ProxyConfiguration | undefined;
    /** @type {Array<Hook>} */
    preNavigationHooks: Array<Hook>;
    /** @type {Array<Hook>} */
    postNavigationHooks: Array<Hook>;
    persistCookiesPerSession: boolean;
    browserPool: BrowserPool<{
        preLaunchHooks: any[];
        postLaunchHooks: any[];
        browserPlugins: readonly import("browser-pool").BrowserPlugin<import("browser-pool/dist/abstract-classes/browser-plugin").CommonLibrary, unknown, import("browser-pool/dist/abstract-classes/browser-plugin").CommonBrowser, unknown, import("browser-pool/dist/abstract-classes/browser-plugin").CommonPage>[];
        maxOpenPagesPerBrowser?: number | undefined;
        retireBrowserAfterPageCount?: number | undefined;
        operationTimeoutSecs?: number | undefined;
        closeInactiveBrowserAfterSecs?: number | undefined;
        useFingerprints?: boolean | undefined;
        fingerprintsOptions?: import("browser-pool").FingerprintsOptions | undefined;
    }, [], never, never, never, never>;
    /**
     * @param {BrowserCrawlingContext & CrawlingContext} crawlingContext
     * @param {*} page
     * @param {boolean} useIncognitoPages
     * @ignore
     * @protected
     * @internal
     */
    protected _enhanceCrawlingContextWithPageInfo(crawlingContext: BrowserCrawlingContext & CrawlingContext, page: any, useIncognitoPages: boolean): void;
    /**
     * @param {BrowserCrawlingContext & CrawlingContext} crawlingContext
     * @ignore
     * @protected
     * @internal
     */
    protected _handleNavigation(crawlingContext: BrowserCrawlingContext & CrawlingContext): Promise<void>;
    /**
     * Marks session bad in case of navigation timeout.
     * @param {BrowserCrawlingContext & CrawlingContext} crawlingContext
     * @param {Error} error
     * @ignore
     * @protected
     * @internal
     */
    protected _handleNavigationTimeout(crawlingContext: BrowserCrawlingContext & CrawlingContext, error: Error): void;
    /**
     * @param {BrowserCrawlingContext & CrawlingContext} crawlingContext
     * @param {Object<string,*>} gotoOptions
     * @ignore
     * @protected
     * @internal
     */
    protected _navigationHandler(crawlingContext: BrowserCrawlingContext & CrawlingContext, gotoOptions: {
        [x: string]: any;
    }): Promise<any>;
    /**
     * Should be overriden in case of different automation library that does not support this response API.
     * // @TODO: This can be also done as a postNavigation hook except the loadedUrl marking.
     * @param {BrowserCrawlingContext & CrawlingContext} crawlingContext
     * @return {Promise<void>}
     * @ignore
     * @protected
     * @internal
     */
    protected _responseHandler(crawlingContext: BrowserCrawlingContext & CrawlingContext): Promise<void>;
    /**
     * @param {string} pageId
     * @param {*} launchContext
     * @ignore
     * @protected
     * @internal
     */
    protected _extendLaunchContext(pageId: string, launchContext: any): Promise<void>;
    /**
     *
     * @param {string} pageId
     * @param {BrowserController} browserController
     * @ignore
     * @protected
     * @internal
     */
    protected _maybeAddSessionRetiredListener(pageId: string, browserController: BrowserController): void;
}
export type BrowserCrawlingContext = {
    browserController: BrowserController;
};
export type Hook = (crawlingContext: BrowserCrawlingContext & CrawlingContext, gotoOptions: {
    [x: string]: any;
}) => Promise<void>;
export type BrowserHandlePageFunction = (context: BrowserCrawlingContext & CrawlingContext) => Promise<void>;
export type GotoFunction = (context: BrowserCrawlingContext & CrawlingContext, gotoOptions: {
    [x: string]: any;
}) => Promise<any>;
export type BrowserCrawlerOptions = {
    /**
     *   Function that is called to process each request.
     *   It is passed an object with the following fields:
     *
     * ```
     * {
     *   request: Request,
     *   response: Response,
     *   page: Page,
     *   session: Session,
     *   browserController: BrowserController,
     *   proxyInfo: ProxyInfo,
     *   crawler: BrowserCrawler,
     * }
     * ```
     *
     *   `request` is an instance of the {@link Request } object with details about the URL to open, HTTP method etc.
     *   `page` is an instance of the `Puppeteer`
     *   [`Page`](https://pptr.dev/#?product=Puppeteer&show=api-class-page) or `Playwright`
     *   [`Page`](https://playwright.dev/docs/api/class-page)
     *   `browserPool` is an instance of the
     *   [`BrowserPool`](https://github.com/apify/browser-pool#BrowserPool),
     *   `browserController` is an instance of the
     *   [`BrowserController`](https://github.com/apify/browser-pool#browsercontroller),
     *   `response` is an instance of the `Puppeteer`
     *   [`Response`](https://pptr.dev/#?product=Puppeteer&show=api-class-response) or `Playwright`
     *   [`Response`](https://playwright.dev/docs/api/class-response),
     *   which is the main resource response as returned by `page.goto(request.url)`.
     *   The function must return a promise, which is then awaited by the crawler.
     *
     *   If the function throws an exception, the crawler will try to re-crawl the
     *   request later, up to `option.maxRequestRetries` times.
     *   If all the retries fail, the crawler calls the function
     *   provided to the `handleFailedRequestFunction` parameter.
     *   To make this work, you should **always**
     *   let your function throw exceptions rather than catch them.
     *   The exceptions are logged to the request using the
     *   {@link RequestpushErrorMessage } function.
     */
    handlePageFunction: BrowserHandlePageFunction;
    /**
     * Timeout in which the function passed as `handlePageFunction` needs to finish, in seconds.
     */
    handlePageTimeoutSecs?: number | undefined;
    /**
     * Navigation function for corresponding library. `page.goto(url)` is supported by both `playwright` and `puppeteer`.
     */
    gotoFunction?: GotoFunction | undefined;
    /**
     * A function to handle requests that failed more than `option.maxRequestRetries` times.
     *
     * The function receives the following object as an argument:
     * ```
     * {
     * request: Request,
     * response: Response,
     * page: Page,
     * browserPool: BrowserPool,
     * autoscaledPool: AutoscaledPool,
     * session: Session,
     * browserController: BrowserController,
     * proxyInfo: ProxyInfo,
     * }
     * ```
     * Where the {@link Request } instance corresponds to the failed request, and the `Error` instance
     * represents the last error thrown during processing of the request.
     */
    handleFailedRequestFunction?: HandleFailedRequest | undefined;
    /**
     * Custom options passed to the underlying [`BrowserPool`](https://github.com/apify/browser-pool#BrowserPool) constructor.
     * You can tweak those to fine-tune browser management.
     */
    browserPoolOptions?: BrowserPoolOptions<import("browser-pool").BrowserPlugin<import("browser-pool/dist/abstract-classes/browser-plugin").CommonLibrary, unknown, import("browser-pool/dist/abstract-classes/browser-plugin").CommonBrowser, unknown, import("browser-pool/dist/abstract-classes/browser-plugin").CommonPage>> | undefined;
    /**
     * Automatically saves cookies to Session. Works only if Session Pool is used.
     */
    persistCookiesPerSession?: boolean | undefined;
    /**
     * If set, `PuppeteerCrawler` will be configured for all connections to use
     * [Apify Proxy](https://console.apify.com/proxy) or your own Proxy URLs provided and rotated according to the configuration.
     * For more information, see the [documentation](https://docs.apify.com/proxy).
     */
    proxyConfiguration?: ProxyConfiguration | undefined;
    /**
     * Async functions that are sequentially evaluated before the navigation. Good for setting additional cookies
     * or browser properties before navigation. The function accepts two parameters, `crawlingContext` and `gotoOptions`,
     * which are passed to the `page.goto()` function the crawler calls to navigate.
     * Example:
     * ```
     * preNavigationHooks: [
     * async (crawlingContext, gotoOptions) => {
     * const { page } = crawlingContext;
     * await page.evaluate((attr) => { window.foo = attr; }, 'bar');
     * },
     * ]
     * ```
     */
    preNavigationHooks?: Hook[] | undefined;
    /**
     * Async functions that are sequentially evaluated after the navigation. Good for checking if the navigation was successful.
     * The function accepts `crawlingContext` as the only parameter.
     * Example:
     * ```
     * postNavigationHooks: [
     * async (crawlingContext) => {
     * const { page } = crawlingContext;
     * if (hasCaptcha(page)) {
     * await solveCaptcha (page);
     * }
     * },
     * ]
     * ```
     */
    postNavigationHooks?: Hook[] | undefined;
    /**
     * Static list of URLs to be processed.
     * Either `requestList` or `requestQueue` option must be provided (or both).
     */
    requestList?: RequestList | undefined;
    /**
     * Dynamic queue of URLs to be processed. This is useful for recursive crawling of websites.
     * Either `requestList` or `requestQueue` option must be provided (or both).
     */
    requestQueue?: RequestQueue | undefined;
    /**
     * Timeout in which the function passed as `handleRequestFunction` needs to finish, in seconds.
     */
    handleRequestTimeoutSecs?: number | undefined;
    /**
     * Indicates how many times the request is retried if {@link BasicCrawlerOptions.handleRequestFunction } fails.
     */
    maxRequestRetries?: number | undefined;
    /**
     * Maximum number of pages that the crawler will open. The crawl will stop when this limit is reached.
     * Always set this value in order to prevent infinite loops in misconfigured crawlers.
     * Note that in cases of parallel crawling, the actual number of pages visited might be slightly higher than this value.
     */
    maxRequestsPerCrawl?: number | undefined;
    /**
     * Custom options passed to the underlying {@link AutoscaledPool } constructor.
     * Note that the `runTaskFunction` and `isTaskReadyFunction` options
     * are provided by `BasicCrawler` and cannot be overridden.
     * However, you can provide a custom implementation of `isFinishedFunction`.
     */
    autoscaledPoolOptions?: AutoscaledPoolOptions | undefined;
    /**
     * Sets the minimum concurrency (parallelism) for the crawl. Shortcut to the corresponding {@link AutoscaledPool } option.
     *
     * *WARNING:* If you set this value too high with respect to the available system memory and CPU, your crawler will run extremely slow or crash.
     * If you're not sure, just keep the default value and the concurrency will scale up automatically.
     */
    minConcurrency?: number | undefined;
    /**
     * Sets the maximum concurrency (parallelism) for the crawl. Shortcut to the corresponding {@link AutoscaledPool } option.
     */
    maxConcurrency?: number | undefined;
    /**
     * Browser crawler will initialize the  {@link SessionPool } with the corresponding `sessionPoolOptions`.
     * The session instance will be than available in the `handleRequestFunction`.
     */
    useSessionPool?: boolean | undefined;
    /**
     * The configuration options for {@link SessionPool } to use.
     */
    sessionPoolOptions?: SessionPoolOptions | undefined;
};
import { BasicCrawler } from "./basic_crawler";
import { ProxyConfiguration } from "../proxy_configuration";
import { BrowserPool } from "browser-pool/dist/browser-pool";
import { CrawlingContext } from "./basic_crawler";
import { BrowserController } from "browser-pool";
import { HandleFailedRequest } from "./basic_crawler";
import { BrowserPoolOptions } from "browser-pool/dist/browser-pool";
import { RequestList } from "../request_list";
import { RequestQueue } from "../storages/request_queue";
import { AutoscaledPoolOptions } from "../autoscaling/autoscaled_pool";
import { SessionPoolOptions } from "../session_pool/session_pool";
//# sourceMappingURL=browser_crawler.d.ts.map