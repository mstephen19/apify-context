"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.limitDepth = exports.getLevelFromEnv = exports.truncate = void 0;
const consts_1 = require("@apify/consts");
const log_consts_1 = require("./log_consts");
/**
 * Ensures a string is shorter than a specified number of character, and truncates it if not, appending a specific suffix to it.
 * (copied from utilities package so logger do not have to depend on all of its dependencies)
 */
function truncate(str, maxLength, suffix = '...[truncated]') {
    maxLength = Math.floor(maxLength);
    // TODO: we should just ignore rest of the suffix...
    if (suffix.length > maxLength) {
        throw new Error('suffix string cannot be longer than maxLength');
    }
    if (typeof str === 'string' && str.length > maxLength) {
        str = str.substr(0, maxLength - suffix.length) + suffix;
    }
    return str;
}
exports.truncate = truncate;
/**
 * Gets log level from env variable. Both integers and strings (WARNING) are supported.
 */
function getLevelFromEnv() {
    const envVar = process.env[consts_1.ENV_VARS.LOG_LEVEL];
    if (!envVar)
        return log_consts_1.LogLevel.INFO;
    if (Number.isFinite(+envVar))
        return +envVar;
    if (log_consts_1.LogLevel[envVar])
        return log_consts_1.LogLevel[envVar];
    return +envVar;
}
exports.getLevelFromEnv = getLevelFromEnv;
/**
 * Limits given object to given depth and escapes function with [function] string.
 *
 * ie. Replaces object's content by '[object]' and array's content
 * by '[array]' when the value is nested more than given limit.
 */
function limitDepth(record, depth, maxStringLength) {
    // handle common cases quickly
    if (typeof record === 'string') {
        return maxStringLength && record.length > maxStringLength ? truncate(record, maxStringLength) : record;
    }
    if (['number', 'boolean'].includes(typeof record) || record == null || record instanceof Date) {
        return record;
    }
    // WORKAROUND: Error's properties are not iterable, convert it to a simple object and preserve custom properties
    // NOTE: _.isError() doesn't work on Match.Error
    if (record instanceof Error) {
        const { name, message, stack } = record, rest = __rest(record, ["name", "message", "stack"]);
        record = Object.assign({ name, message, stack }, rest);
    }
    const nextCall = (rec) => limitDepth(rec, depth - 1, maxStringLength);
    if (Array.isArray(record)) {
        return (depth ? record.map(nextCall) : '[array]');
    }
    if (typeof record === 'object' && record !== null) {
        const mapObject = (obj) => {
            const res = {};
            Object.keys(obj).forEach((key) => {
                res[key] = nextCall(obj[key]);
            });
            return res;
        };
        return depth ? mapObject(record) : '[object]';
    }
    // Replaces all function with [function] string
    if (typeof record === 'function') {
        return '[function]';
    }
    // this shouldn't happen
    console.log(`WARNING: Object cannot be logged: ${record}`);
    return undefined;
}
exports.limitDepth = limitDepth;
