"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerText = void 0;
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const logger_1 = require("./logger");
const log_consts_1 = require("./log_consts");
const SHORTEN_LEVELS = {
    SOFT_FAIL: 'SFAIL',
    WARNING: 'WARN',
};
const LEVEL_TO_COLOR = {
    [log_consts_1.LogLevel.ERROR]: 'red',
    [log_consts_1.LogLevel.SOFT_FAIL]: 'red',
    [log_consts_1.LogLevel.WARNING]: 'yellow',
    [log_consts_1.LogLevel.INFO]: 'green',
    [log_consts_1.LogLevel.DEBUG]: 'blue',
    [log_consts_1.LogLevel.PERF]: 'magenta',
};
const SHORTENED_LOG_LEVELS = log_consts_1.LEVEL_TO_STRING.map((level) => SHORTEN_LEVELS[level] || level);
const MAX_LEVEL_LENGTH_SPACES = Math.max(...SHORTENED_LOG_LEVELS.map((l) => l.length));
const getLevelIndent = (level) => {
    let spaces = '';
    for (let i = 0; i < MAX_LEVEL_LENGTH_SPACES - level.length; i++)
        spaces += ' ';
    return spaces;
};
const DEFAULT_OPTIONS = {
    skipTime: true,
};
class LoggerText extends logger_1.Logger {
    constructor(options = {}) {
        super(Object.assign(Object.assign({}, DEFAULT_OPTIONS), options));
    }
    _log(level, message, data, exception, opts = {}) {
        let { prefix, suffix } = opts;
        let maybeDate = '';
        if (!this.options.skipTime) {
            maybeDate = `${(new Date()).toISOString().replace('Z', '').replace('T', ' ')} `;
        }
        const errStack = exception ? this._parseException(exception) : '';
        const color = LEVEL_TO_COLOR[level];
        const levelStr = SHORTENED_LOG_LEVELS[level];
        const levelIndent = getLevelIndent(levelStr);
        const dataStr = !data ? '' : ` ${JSON.stringify(data)}`;
        prefix = prefix ? ` ${prefix}${log_consts_1.PREFIX_DELIMITER}` : '';
        suffix = suffix ? ` ${suffix}` : '';
        const line = `${ansi_colors_1.default.gray(maybeDate)}${ansi_colors_1.default[color](levelStr)}${levelIndent}${ansi_colors_1.default.yellow(prefix)} ${message || ''}${ansi_colors_1.default.gray(dataStr)}${ansi_colors_1.default.yellow(suffix)}${errStack}`; // eslint-disable-line
        this._outputWithConsole(level, line);
        return line;
    }
    _parseException(exception) {
        let errStack = '';
        // Parse error.type and error.details from ApifyClientError.
        const errDetails = [];
        if (exception.type)
            errDetails.push(`type=${exception.type}`);
        if (exception.details) {
            Object.entries(exception.details).map(([key, val]) => errDetails.push(`${key}=${val}`));
        }
        // Parse error stack lines.
        // NOTE: Reason is here to support Meteor.js like errors.
        const errorString = exception.stack || exception.reason || exception.toString();
        const errorLines = errorString.split('\n');
        // Add details to a first line.
        if (errDetails.length)
            errorLines[0] += ansi_colors_1.default.gray(`(details: ${errDetails.join(', ')})`);
        // Compose it back.
        errStack = errorLines.map((line) => `  ${line}`).join('\n');
        errStack = `\n${errStack}`;
        return errStack;
    }
}
exports.LoggerText = LoggerText;
