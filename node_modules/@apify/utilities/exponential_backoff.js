"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryWithExpBackoff = exports.RetryableError = void 0;
const log_1 = __importDefault(require("@apify/log"));
const utilities_1 = require("./utilities");
class RetryableError extends Error {
    constructor(error, ...args) {
        super(...args);
        this.error = error;
    }
}
exports.RetryableError = RetryableError;
async function retryWithExpBackoff(params = {}) {
    const { func, expBackoffMillis, expBackoffMaxRepeats } = params;
    if (typeof func !== 'function') {
        throw new Error('Parameter "func" should be a function.');
    }
    if (typeof expBackoffMillis !== 'number') {
        throw new Error('Parameter "expBackoffMillis" should be a number.');
    }
    if (typeof expBackoffMaxRepeats !== 'number') {
        throw new Error('Parameter "expBackoffMaxRepeats" should be a number.');
    }
    for (let i = 0;; i++) {
        let error;
        try {
            return await func();
        }
        catch (e) {
            error = e;
        }
        if (!(error instanceof RetryableError)) {
            throw error;
        }
        if (i >= expBackoffMaxRepeats - 1) {
            throw error.error;
        }
        const waitMillis = expBackoffMillis * (2 ** i);
        const rand = (from, to) => from + Math.floor(Math.random() * (to - from + 1));
        const randomizedWaitMillis = rand(waitMillis, waitMillis * 2);
        if (i === Math.round(expBackoffMaxRepeats / 2)) {
            log_1.default.warning(`Retry failed ${i} times and will be repeated in ${randomizedWaitMillis}ms`, {
                originalError: error.error.message,
                errorDetails: error.error.details,
            });
        }
        await (0, utilities_1.delayPromise)(randomizedWaitMillis);
    }
}
exports.retryWithExpBackoff = retryWithExpBackoff;
