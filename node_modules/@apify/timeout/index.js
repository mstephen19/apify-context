"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addTimeoutToPromise = exports.tryCancel = exports.TimeoutError = exports.storage = void 0;
// eslint-disable-next-line max-classes-per-file
const async_hooks_1 = require("async_hooks");
/**
 * `AsyncLocalStorage` instance that is used for baring the AbortContext inside user provided handler.
 * We can use it to access the `AbortContext` instance via `storage.getStore()`, and there we can access
 * `cancelTask` instance of `AbortController`.
 */
exports.storage = new async_hooks_1.AsyncLocalStorage();
/**
 * Custom error class that will be used for timeout error.
 */
class TimeoutError extends Error {
}
exports.TimeoutError = TimeoutError;
/**
 * Custom error class to handle `tryCancel()` checks.
 * This should not be exposed to user land, as it will be caught in.
 */
class InternalTimeoutError extends TimeoutError {
}
/**
 * Checks whether we are inside timeout handler created by this package, and cancels current
 * task execution by throwing `TimeoutError`. This error will be ignored if the promise timed
 * out already, or explicitly skipped in `addTimeoutToPromise`.
 *
 * Use this function after every async call that runs inside the timeout handler:
 *
 * ```ts
 * async function doSomething() {
 *     await doSomethingTimeConsuming();
 *     tryCancel();
 *     await doSomethingElse();
 *     tryCancel();
 * }
 * ```
 */
function tryCancel() {
    var _a;
    const signal = (_a = exports.storage.getStore()) === null || _a === void 0 ? void 0 : _a.cancelTask.signal;
    if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
        throw new InternalTimeoutError('Promise handler has been canceled due to a timeout');
    }
}
exports.tryCancel = tryCancel;
/**
 * Runs given handler and rejects with the given `errorMessage` (or `Error` instance)
 * after given `timeoutMillis`, unless the original promise resolves or rejects earlier.
 * Use `tryCancel()` function inside the handler after each await to finish its execution
 * early when the timeout appears.
 *
 * ```ts
 * const res = await addTimeoutToPromise(
 *   () => handler(),
 *   200,
 *   'Handler timed out after 200ms!',
 * );
 * ```
 */
async function addTimeoutToPromise(handler, timeoutMillis, errorMessage) {
    var _a;
    // respect existing context to support nesting
    const context = (_a = exports.storage.getStore()) !== null && _a !== void 0 ? _a : {
        cancelTask: new AbortController(),
    };
    let returnValue;
    // calls handler, skips internal `TimeoutError`s that might have been thrown
    // via `tryCancel()` and aborts the timeout promise after the handler finishes
    const wrap = async () => {
        try {
            returnValue = await handler();
        }
        catch (e) {
            if (!(e instanceof InternalTimeoutError)) {
                throw e;
            }
        }
    };
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            context.cancelTask.abort();
            const error = errorMessage instanceof Error ? errorMessage : new TimeoutError(errorMessage);
            reject(error);
        }, timeoutMillis);
        exports.storage.run(context, () => {
            wrap()
                .then(() => resolve(returnValue))
                .catch(reject)
                .finally(() => clearTimeout(timeout));
        });
    });
}
exports.addTimeoutToPromise = addTimeoutToPromise;
